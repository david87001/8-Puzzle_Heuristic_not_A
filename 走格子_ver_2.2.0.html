<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>8-puzzle game</title>
    <style>
        body {
            margin: 0;
            font-family: "Microsoft JhengHei", sans-serif;
            background: linear-gradient(to bottom, #e0f7fa, #fff);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1#step_count {
            margin-top: 20px;
            font-size: 2rem;
            color: #0277bd;
            text-shadow: 1px 1px 2px #bbb;
        }

        canvas#myCanvas {
            border: 3px solid #333;
            margin: 20px 0;
            max-width: 90%;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            width: 100px;
            height: 100px;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            background: linear-gradient(to bottom right, #4fc3f7, #0288d1);
            border: none;
            border-radius: 15px;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }

        button:hover {
            transform: scale(1.05);
            cursor: pointer;
        }

        #main-button {
            background: linear-gradient(to bottom right, #ffa726, #fb8c00);
            font-size: 1.2rem;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 167, 38, 0.4);
            }

            50% {
                transform: scale(1.1);
                box-shadow: 0 0 15px 5px rgba(255, 167, 38, 0.3);
            }
        }

        #state_possibility_world {
            background-color: #e3f2fd;
            border-left: 5px solid #0288d1;
            padding: 10px 15px;
            margin: 20px;
            font-size: 1rem;
            max-width: 90%;
            color: #01579b;
        }

        #isCal {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-size: 0.9rem;
            color: #999;
            background: #f1f1f1;
            padding: 5px 10px;
            border-radius: 8px;
            box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.2);
        }

        .mobile-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            margin: 30px 0;
            width: 320px;
        }

        .mobile-controls button {
            width: 100%;
            height: 80px;
            background: linear-gradient(to bottom right, #aed581, #7cb342);
        }

        .mobile-controls .blank {
            visibility: hidden;
        }

        @media (min-width: 768px) {
            .mobile-controls {
                width: 400px;
            }
        }
    </style>
</head>

<body>

    <h1 id="step_count">目前走了__步</h1>

    <canvas id="myCanvas" width="300" height="300"></canvas>

    <p id="state_possibility_world">
        這次我總共計算了...
    </p>
    <div class="button-group">
        <button onclick="Shuffle()">洗牌</button>
        <button onclick="calculate_all()">廣度優先遍歷</button>
        <button onclick="calculate_all_Imitation()">模仿策略遍歷</button>
        <button id="main-button" onclick="auto_action_button()">自動解謎</button>
    </div>

    <div class="mobile-controls">
        <div class="blank"></div>
        <button onclick="user_up()">上</button>
        <div class="blank"></div>
        <button onclick="user_left()">左</button>
        <div class="blank"></div>
        <button onclick="user_right()">右</button>
        <div class="blank"></div>
        <button onclick="user_down()">下</button>
        <div class="blank"></div>
    </div>

    

    <p id="isCal">空閒中</p>

    <script>
        //這一個可以自己設置
        var world_n = 3;
        var deep_n = 13;//16沒有比15好，目前13效果最好
        var deep_n_part = 9;//後續採用模擬計算，先排好第一層，再排左邊，成功減少了許多計算量
        var deep_n_A = 20;//試試看

        var numbers = [];
        var numbers_answer = [];
        var numbers_store = [];
        var ASF_auto = [[], [], 10000];
        for (var first_i = 0; first_i < (world_n * world_n); first_i++) {
            numbers.push(((first_i + 1) % (world_n * world_n)));
            numbers_answer.push(((first_i + 1) % (world_n * world_n)));

        }
        console.log(numbers);

        var action_array = [];//實際去走走看;
        var isAction = false;
        var isAction_toZero = false;

        //文字變數
        var word_state = 0;
        var word_step = 0;
        var winner_now = "";

        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");
        canvas.height = 400;
        canvas.width = 400;

        function user_up() {
            up();
            //文字
            document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了...';
            //因為移動了，所以動作歸零
            isAction_toZero = true;
        }
        function user_down() {
            down();
            //文字
            document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了...';
            //因為移動了，所以動作歸零
            isAction_toZero = true;
        }
        function user_left() {
            left();
            //文字
            document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了...';
            //因為移動了，所以動作歸零
            isAction_toZero = true;
        }
        function user_right() {
            right();
            //文字
            document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了...';
            //因為移動了，所以動作歸零
            isAction_toZero = true;
        }
        //鍵盤事件
        var body = document.body;
        function goRocket(e) {
            //console.log(e.keyCode); //查鍵盤代碼
            switch (e.keyCode) {
                case 83:
                    Shuffle();
                    break;
                case 38:
                    user_up();
                    break;
                case 40:
                    user_down();
                    break;
                case 37:
                    user_left();
                    break;
                case 39:
                    user_right();
                    break;
            }
        }
        body.addEventListener('keydown', goRocket, false) //偵測按下按鍵的行為

        function draw_basis() {
            for (var draw_basis_i = 0; draw_basis_i < (world_n - 1); draw_basis_i++) {
                //在繪製任何東西之前，我們都要來個開始，像全天下所有的故事一樣
                ctx.beginPath();
                //我們用moveTo(x,y)來指定線的起點座標
                ctx.moveTo(0, (400 / world_n) * (draw_basis_i + 1))
                //之後使用lineTo(x,y)來指定與前一個座標相連的點
                ctx.lineTo(400, (400 / world_n) * (draw_basis_i + 1))
                //用stroke()來繪製相連點的線
                ctx.stroke()
            }
            for (var draw_basis_i = 0; draw_basis_i < (world_n - 1); draw_basis_i++) {
                //在繪製任何東西之前，我們都要來個開始，像全天下所有的故事一樣
                ctx.beginPath();
                //我們用moveTo(x,y)來指定線的起點座標
                ctx.moveTo((400 / world_n) * (draw_basis_i + 1), 0)
                //之後使用lineTo(x,y)來指定與前一個座標相連的點
                ctx.lineTo((400 / world_n) * (draw_basis_i + 1), 400)
                //用stroke()來繪製相連點的線
                ctx.stroke()
            }
        }
        function draw_number() {
            ctx.font = "50px Arial";
            for (var draw_number_i = 0; draw_number_i < (world_n * world_n); draw_number_i++) {
                if (draw_number_i == numbers.indexOf(0)) {
                    ctx.beginPath();
                    ctx.arc((draw_number_i % world_n) * (400 / world_n) + (400 / world_n / 2), ((draw_number_i - (draw_number_i % world_n)) / world_n) * (400 / world_n) + (400 / world_n / 2), (400 / world_n / 2) * 0.8, 0, 2 * Math.PI);
                    ctx.stroke();
                    continue;
                }
                ctx.fillText(numbers[draw_number_i], (draw_number_i % world_n) * (400 / world_n), ((draw_number_i - (draw_number_i % world_n)) / world_n) * (400 / world_n) + 50);
            }
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            draw_basis();
            draw_number();
        }

        //隨機數
        function getRandomInt(max) {
            return Math.floor(Math.random() * max);
        }
        //引出來歸零action_array
        function action_array_0() {
            if (isAction_toZero) {
                //動作歸零
                action_array = [];
                isAction_toZero = false;
            }
        }
        //洗牌
        function Shuffle() {
            //文字
            document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了...';

            let Shuffle_aa = 0;
            for (var Shuffle_i = 0; Shuffle_i < 10000; Shuffle_i++) {
                Shuffle_aa = getRandomInt(4);
                if (Shuffle_aa == 0) {
                    up();
                }
                if (Shuffle_aa == 1) {
                    down();
                }
                if (Shuffle_aa == 2) {
                    left();
                }
                if (Shuffle_aa == 3) {
                    right();
                }
            }
            //因為移動了，所以動作歸零
            isAction_toZero = true;
        }


        //開始計算
        function calculate_all() {
            let now = Date.now();

            //文字改變
            document.getElementById("isCal").innerHTML = "計算中...";

            let ASF_auto_in = [];
            word_state = 0;//後續在find_best_action裡面有更新
            ASF_auto = [[], [], 500];
            ASF_auto[1] = ASF_auto[1].concat(numbers);
            for (let auto_i = 0; auto_i < 10; auto_i++) {
                ASF_auto_in = find_best_action(ASF_auto[1]);
                ASF_auto[0] = ASF_auto[0].concat(ASF_auto_in[0]);
                ASF_auto[1] = [];
                ASF_auto[1] = ASF_auto[1].concat(ASF_auto_in[1]);
                ASF_auto[2] = ASF_auto_in[2];
                if (ASF_auto[2] == 0) {
                    break;
                }
            }




            console.log("在更新之前看一下action_array.length", action_array.length);
            if (action_array.length == 0) {
                //沒路徑，不管了
                winner_now = "廣度優先遍歷";
                action_array = action_array.concat(ASF_auto[0]);
                console.log("(因為沒資料更新了)", ASF_auto);
            } else {
                //已經有路徑的情況下
                if (ASF_auto[2] == 0 && ASF_auto[0].length < action_array.length) {
                    //新路徑有到終點 且 新路徑比較小
                    action_array = [];
                    action_array = action_array.concat(ASF_auto[0]);
                    winner_now = "廣度優先遍歷";
                    console.log("(資料更好就更新了)", ASF_auto);
                } else {
                    //否則不更新
                    console.log("(沒更新)", ASF_auto);
                }
            }
            //文字
            if (ASF_auto[2] == 0) {
                document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了 ' + word_state + '個可能性，目前最好的步數是「' + winner_now + "」算出的" + action_array.length + "步(這次算出" + ASF_auto[0].length + "步啦哈哈)";
            } else {
                document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了 ' + word_state + '個可能性，目前最好的步數是「' + winner_now + "」算出的" + action_array.length + "步(這次沒算出啦哈哈)";
            }
            console.log("耗時", (Date.now() - now)/1000, "秒");
            //auto_action_button();
        }

        function calculate_all_Imitation() {
            let now = Date.now();

            //文字改變
            document.getElementById("isCal").innerHTML = "計算中...";

            let ASF_auto_in = [];
            word_state = 0;//後續在find_best_action裡面有更新
            ASF_auto = [[], [], 500];
            ASF_auto[1] = ASF_auto[1].concat(numbers);
            for (let auto_i = 0; auto_i < 10; auto_i++) {
                ASF_auto_in = find_best_action_part(ASF_auto[1], [1, -1, -1, -1, -1, -1, -1, -1, -1]);
                ASF_auto[0] = ASF_auto[0].concat(ASF_auto_in[0]);
                ASF_auto[1] = [];
                ASF_auto[1] = ASF_auto[1].concat(ASF_auto_in[1]);
                ASF_auto[2] = ASF_auto_in[2];
                if (ASF_auto[2] == 0) {
                    break;
                }
            }
            for (let auto_i = 0; auto_i < 10; auto_i++) {
                ASF_auto_in = find_best_action_part(ASF_auto[1], [1, 2, 3, -1, -1, -1, -1, -1, -1]);
                ASF_auto[0] = ASF_auto[0].concat(ASF_auto_in[0]);
                ASF_auto[1] = [];
                ASF_auto[1] = ASF_auto[1].concat(ASF_auto_in[1]);
                ASF_auto[2] = ASF_auto_in[2];
                if (ASF_auto[2] == 0) {
                    break;
                }
            }
            for (let auto_i = 0; auto_i < 10; auto_i++) {
                ASF_auto_in = find_best_action_part(ASF_auto[1], [1, 2, 3, 4, -1, -1, 7, -1, -1]);
                ASF_auto[0] = ASF_auto[0].concat(ASF_auto_in[0]);
                ASF_auto[1] = [];
                ASF_auto[1] = ASF_auto[1].concat(ASF_auto_in[1]);
                ASF_auto[2] = ASF_auto_in[2];
                if (ASF_auto[2] == 0) {
                    break;
                }
            }
            for (let auto_i = 0; auto_i < 10; auto_i++) {
                ASF_auto_in = find_best_action_part(ASF_auto[1], [1, 2, 3, 4, 5, 6, 7, 8, 0]);
                ASF_auto[0] = ASF_auto[0].concat(ASF_auto_in[0]);
                ASF_auto[1] = [];
                ASF_auto[1] = ASF_auto[1].concat(ASF_auto_in[1]);
                ASF_auto[2] = ASF_auto_in[2];
                if (ASF_auto[2] == 0) {
                    break;
                }
            }

            console.log("在更新之前看一下action_array.length", action_array.length);
            if (action_array.length == 0) {
                //沒路徑，不管了
                winner_now = "模仿策略";
                action_array = action_array.concat(ASF_auto[0]);
                console.log("(因為沒資料更新了)", ASF_auto);
            } else {
                //已經有路徑的情況下
                if (ASF_auto[2] == 0 && ASF_auto[0].length < action_array.length) {
                    //新路徑有到終點 且 新路徑比較小
                    action_array = [];
                    action_array = action_array.concat(ASF_auto[0]);
                    winner_now = "模仿策略";
                    console.log("(資料更好就更新了)", ASF_auto);
                } else {
                    //否則不更新
                    console.log("(沒更新)", ASF_auto);
                }
            }

            //文字
            if (ASF_auto[2] == 0) {
                document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了 ' + word_state + '個可能性，目前最好的步數是「' + winner_now + "」算出的" + action_array.length + "步(這次算出" + ASF_auto[0].length + "步啦哈哈)";
            } else {
                document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了 ' + word_state + '個可能性，目前最好的步數是「' + winner_now + "」算出的" + action_array.length + "步(這次沒算出啦哈哈)";
            }

            console.log("耗時", (Date.now() - now)/1000, "秒");

            //auto_action_button();
        }

        function calculate_all_A_star() {
            let now = Date.now();
            //文字改變
            document.getElementById("isCal").innerHTML = "計算中...";

            let ASF_auto_in = [];
            word_state = 0;//後續在find_best_action裡面有更新
            ASF_auto = [[], [], 500];
            ASF_auto[1] = ASF_auto[1].concat(numbers);
            for (let auto_i = 0; auto_i < 2; auto_i++) {
                ASF_auto_in = find_best_action_A_star(ASF_auto[1]);
                ASF_auto[0] = ASF_auto[0].concat(ASF_auto_in[0]);
                ASF_auto[1] = [];
                ASF_auto[1] = ASF_auto[1].concat(ASF_auto_in[1]);
                ASF_auto[2] = ASF_auto_in[2];
                if (ASF_auto[2] == 0) {
                    break;
                }
            }


            console.log("在更新之前看一下action_array.length", action_array.length);
            if (action_array.length == 0) {
                //沒路徑，不管了
                action_array = action_array.concat(ASF_auto[0]);
                console.log("(因為沒資料更新了)", ASF_auto);
            } else {
                //已經有路徑的情況下
                //if (ASF_auto[2] == 0 && ASF_auto[0].length < action_array.length) {
                if (1) {

                    //新路徑有到終點 且 新路徑比較小
                    action_array = [];
                    action_array = action_array.concat(ASF_auto[0]);
                    console.log("(資料更好就更新了)", ASF_auto);
                } else {
                    //否則不更新
                    console.log("(沒更新)", ASF_auto);
                }
            }
            //文字
            if (ASF_auto[2] == 0) {
                document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了 ' + word_state + '個可能性，目前最好的步數是「' + winner_now + "」算出的" + action_array.length + "步(這次算出" + ASF_auto[0].length + "步啦哈哈)";
            } else {
                document.getElementById("state_possibility_world").innerHTML = '這次我總共計算了 ' + word_state + '個可能性，目前最好的步數是「' + winner_now + "」算出的" + action_array.length + "步(這次沒算出啦哈哈)";
            }
            console.log("耗時", (Date.now() - now)/1000, "秒");

            //auto_action_button();
        }


        //讀取action_array裡面的東西，實際去走走看
        function auto_action() {
            //沒有啟動
            if (!isAction) {
                return 0;
            }
            if (action_array.length == 0) {
                //結束
                word_step = 0;
                isAction = false;
                console.log(action_array);
                return 0;
            } else {
                number_to_walk(action_array[0]);
                word_step++;
                document.getElementById("step_count").innerHTML = "目前走了 " + word_step + "步";
                action_array.shift();
                console.log(action_array);
            }
        }

        //呈上，auto按鈕
        function auto_action_button() {
            isAction = !isAction;
        }


        function find_best_action(state_firse) {
            let state_all = [];
            let action_next = 5;
            let action_next_array = [];
            let action_skip = [];

            let ASF = [[], [], 10000];//[action、state、f]
            state_all.push([5, state_firse, calculate_h(state_firse)]);


            //看要計算幾層
            for (let deep_n_i = 0; deep_n_i < deep_n; deep_n_i++) {
                //console.log("目前到第", deep_n_i , "層");
                //從現有的state取出一個state
                let state_amount = state_all.length;
                for (let all_S_i = 0; all_S_i < state_amount; all_S_i++) {
                    //console.log("遇到了", state_all[all_S_i]);
                    action_skip = [];//要跳過的步數
                    //先走四步，看看會走到什麼地方，存在「這次會走到的state」變量
                    for (let next_action_i = 0; next_action_i < 4; next_action_i++) {
                        let state_try = [];
                        [action_next, state_try] = action_test(state_all[all_S_i][1], next_action_i);

                        //如果這一步走下去跟之前一樣，把這一步加入到skip名單內，讓下一階段跳過
                        if (state_check(state_try, state_all)) {
                            action_skip.push(next_action_i);
                        }
                    }

                    //能行動的步數，f值存起來，還有該怎麼到達的action順序
                    for (let next_action_i = 0; next_action_i < 4; next_action_i++) {
                        //看看有沒有在skip名單內，有就跳過
                        if (action_skip.includes(next_action_i)) {
                            continue;
                        }

                        action_next = 5;

                        //初始化「這次的行動」為停止
                        ASF = [[], [], 10000];//[action、state、f]


                        let state_try = [];
                        [action_next, state_try] = action_test(state_all[all_S_i][1], next_action_i);

                        //比對有沒有跟之前的一樣，如果跟之前一樣，不要動並且跳過換下一個動作
                        //更新[action、state、f]變量
                        ASF[0] = ASF[0].concat(state_all[all_S_i][0]);
                        ASF[0].push(action_next);
                        ASF[1] = ASF[1].concat(state_try);
                        //ASF[2] = (deep_n_i) + calculate_h(state_try);
                        ASF[2] = calculate_h(state_try);

                        //console.log(ASF[0]);

                        //最後儲存當前位置
                        state_all.push(ASF);
                        //console.log("state_all", state_all);
                    }
                }
            }

            //文字部分
            word_state = word_state + state_all.length;

            //得出結果，按照「action、state、f」變量的action真實行動
            //找到f值最低的
            let f_smallist = 10000;
            let f_smallist_i = 0;
            for (let all_S_i = 0; all_S_i < state_all.length; all_S_i++) {
                if (state_all[all_S_i][2] < f_smallist) {
                    f_smallist = state_all[all_S_i][2];
                    f_smallist_i = all_S_i;
                }
                if (state_all[all_S_i][2] == f_smallist) {
                    if (getRandomInt(2)) {
                        f_smallist = state_all[all_S_i][2];
                        f_smallist_i = all_S_i;
                    }

                }
            }
            console.log("總共算了：" + state_all.length + "個")
            console.log("最小的是：", f_smallist_i, "號");
            console.log(state_all[f_smallist_i]);
            action_next_array = action_next_array.concat(state_all[f_smallist_i][0]);
            //return action_next_array;
            return state_all[f_smallist_i];
        }


        function find_best_action_part(state_firse, state_end) {
            let state_all = [];
            let action_next = 5;
            let action_next_array = [];
            let action_skip = [];

            let ASF = [[], [], 10000];//[action、state、f]
            state_all.push([5, state_firse, calculate_h(state_firse)]);


            //看要計算幾層
            for (let deep_n_part_i = 0; deep_n_part_i < deep_n_part; deep_n_part_i++) {
                //console.log("目前到第", deep_n_part_i , "層");
                //從現有的state取出一個state
                let state_amount = state_all.length;
                for (let all_S_i = 0; all_S_i < state_amount; all_S_i++) {
                    //console.log("遇到了", state_all[all_S_i]);
                    action_skip = [];//要跳過的步數
                    //先走四步，看看會走到什麼地方，存在「這次會走到的state」變量
                    for (let next_action_i = 0; next_action_i < 4; next_action_i++) {
                        let state_try = [];
                        [action_next, state_try] = action_test(state_all[all_S_i][1], next_action_i);

                        //如果這一步走下去跟之前一樣，把這一步加入到skip名單內，讓下一階段跳過
                        if (state_check(state_try, state_all)) {
                            action_skip.push(next_action_i);
                        }
                    }

                    //能行動的步數，f值存起來，還有該怎麼到達的action順序
                    for (let next_action_i = 0; next_action_i < 4; next_action_i++) {
                        //看看有沒有在skip名單內，有就跳過
                        if (action_skip.includes(next_action_i)) {
                            continue;
                        }

                        action_next = 5;

                        //初始化「這次的行動」為停止
                        ASF = [[], [], 10000];//[action、state、f]


                        let state_try = [];
                        [action_next, state_try] = action_test(state_all[all_S_i][1], next_action_i);

                        //比對有沒有跟之前的一樣，如果跟之前一樣，不要動並且跳過換下一個動作
                        //更新[action、state、f]變量
                        ASF[0] = ASF[0].concat(state_all[all_S_i][0]);
                        ASF[0].push(action_next);
                        ASF[1] = ASF[1].concat(state_try);
                        //ASF[2] = (deep_n_part_i) + calculate_h(state_try);
                        ASF[2] = calculate_h_part(state_try, state_end);

                        //console.log(ASF[0]);

                        //最後儲存當前位置
                        state_all.push(ASF);
                        //console.log("state_all", state_all);
                    }
                }
            }

            //文字部分
            word_state = word_state + state_all.length;

            //得出結果，按照「action、state、f」變量的action真實行動
            //找到f值最低的
            let f_smallist = 10000;
            let f_smallist_i = 0;
            for (let all_S_i = 0; all_S_i < state_all.length; all_S_i++) {
                if (state_all[all_S_i][2] < f_smallist) {
                    f_smallist = state_all[all_S_i][2];
                    f_smallist_i = all_S_i;
                }
                if (state_all[all_S_i][2] == f_smallist) {
                    if (getRandomInt(2)) {
                        f_smallist = state_all[all_S_i][2];
                        f_smallist_i = all_S_i;
                    }

                }
            }
            console.log("總共算了：" + state_all.length + "個")
            console.log("最小的是：", f_smallist_i, "號");
            console.log(state_all[f_smallist_i]);
            action_next_array = action_next_array.concat(state_all[f_smallist_i][0]);
            //return action_next_array;
            return state_all[f_smallist_i];
        }

        function find_best_action_A_star(state_firse) {
            let state_all = [];
            let action_next = 5;
            let action_next_array = [];
            let action_skip = [];

            let smallest_f = 10000;

            let ASF = [[], [], 10000];//[action、state、f]
            state_all.push([5, state_firse, calculate_h(state_firse)]);


            //看要計算幾層
            for (let deep_n_A_i = 0; deep_n_A_i < deep_n_A; deep_n_A_i++) {
                //console.log("目前到第", deep_n_A_i , "層");
                if (deep_n_A_i > smallest_f * 2) {
                    break;
                }
                //從現有的state取出一個state
                let state_amount = state_all.length;
                for (let all_S_i = 0; all_S_i < state_amount; all_S_i++) {
                    //console.log("遇到了", state_all[all_S_i]);
                    action_skip = [];//要跳過的步數
                    //先走四步，看看會走到什麼地方，存在「這次會走到的state」變量
                    for (let next_action_i = 0; next_action_i < 4; next_action_i++) {
                        let state_try = [];
                        [action_next, state_try] = action_test(state_all[all_S_i][1], next_action_i);

                        //如果這一步走下去跟之前一樣，把這一步加入到skip名單內，讓下一階段跳過
                        if (state_check(state_try, state_all)) {
                            action_skip.push(next_action_i);
                        }
                    }

                    //能行動的步數，f值存起來，還有該怎麼到達的action順序
                    for (let next_action_i = 0; next_action_i < 4; next_action_i++) {
                        //看看有沒有在skip名單內，有就跳過
                        if (action_skip.includes(next_action_i)) {
                            continue;
                        }

                        action_next = 5;

                        //初始化「這次的行動」為停止
                        ASF = [[], [], 10000];//[action、state、f]


                        let state_try = [];
                        [action_next, state_try] = action_test(state_all[all_S_i][1], next_action_i);

                        //比對有沒有跟之前的一樣，如果跟之前一樣，不要動並且跳過換下一個動作
                        //更新[action、state、f]變量
                        ASF[0] = ASF[0].concat(state_all[all_S_i][0]);
                        ASF[0].push(action_next);
                        ASF[1] = ASF[1].concat(state_try);
                        ASF[2] = 0.5 * (deep_n_A_i - 1) + calculate_h(state_try);

                        if (smallest_f > ASF[2]) {
                            smallest_f = ASF[2];
                        }

                        console.log(ASF);

                        //最後儲存當前位置
                        state_all.push(ASF);
                        //console.log("state_all", state_all);
                    }
                }
            }

            //文字部分
            word_state = word_state + state_all.length;

            //得出結果，按照「action、state、f」變量的action真實行動
            //找到f值最低的
            let f_smallist = 10000;
            let f_smallist_i = 0;
            for (let all_S_i = 0; all_S_i < state_all.length; all_S_i++) {
                if (state_all[all_S_i][2] < f_smallist) {
                    f_smallist = state_all[all_S_i][2];
                    f_smallist_i = all_S_i;
                }
                if (state_all[all_S_i][2] == f_smallist) {
                    if (getRandomInt(2)) {
                        f_smallist = state_all[all_S_i][2];
                        f_smallist_i = all_S_i;
                    }

                }
            }
            console.log("總共算了：" + state_all.length + "個")
            console.log("最小的是：", f_smallist_i, "號");
            console.log(state_all[f_smallist_i]);
            action_next_array = action_next_array.concat(state_all[f_smallist_i][0]);
            //return action_next_array;
            return state_all[f_smallist_i];
        }

        //交換這個state的格子
        function change(state, change_i, change_j) {
            let state_change = [];
            for (let i = 0; i < state.length; i++) {
                state_change.push(state[i])
            }
            [state_change[change_i], state_change[change_j]] = [state_change[change_j], state_change[change_i]];
            return state_change;
        }

        //真實移動
        function up() {
            if (numbers.indexOf(0) >= world_n) {
                numbers = change(numbers, numbers.indexOf(0), numbers.indexOf(0) - world_n);
                return 1;
            }
            return 0;
        }
        function down() {
            if (numbers.indexOf(0) < (world_n * world_n) - world_n) {
                numbers = change(numbers, numbers.indexOf(0), numbers.indexOf(0) + world_n);
                return 1;
            }
            return 0;
        }
        function left() {
            if (numbers.indexOf(0) % world_n != 0) {
                numbers = change(numbers, numbers.indexOf(0), numbers.indexOf(0) - 1);
                return 1;
            }
            return 0;
        }
        function right() {
            if (numbers.indexOf(0) % world_n != (world_n - 1)) {
                numbers = change(numbers, numbers.indexOf(0), numbers.indexOf(0) + 1);
                return 1;
            }
            return 0;
        }


        //比較兩個矩陣
        function arraysEqual(arraysEqual_a, arraysEqual_b) {
            if (arraysEqual_a === arraysEqual_b) {
                //console.log("true");
                return true;
            }
            if (arraysEqual_a == null || arraysEqual_b == null) {
                //console.log("false");
                return false;
            }
            if (arraysEqual_a.length !== arraysEqual_b.length) {
                //console.log("false");
                return false;
            }

            for (var i = 0; i < arraysEqual_a.length; ++i) {
                if (arraysEqual_a[i] !== arraysEqual_b[i]) {
                    //console.log("false");
                    return false;
                }
            }
            return true;
        }

        //查看這佪state在經過某個action會去哪裡
        function action_test(state, action) {
            let state_next = [];

            for (let i = 0; i < state.length; i++) {
                state_next.push(state[i])
            }

            if (action == 0) {
                if (state.indexOf(0) >= world_n) {
                    state_next = change(state, state.indexOf(0), state.indexOf(0) - world_n);
                }
            }
            if (action == 1) {
                if (state.indexOf(0) < (world_n * world_n) - world_n) {
                    state_next = change(state, state.indexOf(0), state.indexOf(0) + world_n);
                }
            }
            if (action == 2) {
                if (state.indexOf(0) % world_n != 0) {
                    state_next = change(state, state.indexOf(0), state.indexOf(0) - 1);
                }
            }
            if (action == 3) {
                if (state.indexOf(0) % world_n != (world_n - 1)) {
                    state_next = change(state, state.indexOf(0), state.indexOf(0) + 1);
                }
            }

            return [action, state_next];
        }


        //真的去依照數字走路
        function number_to_walk(aa) {
            if (aa == 0) {
                up();
            }
            if (aa == 1) {
                down();
            }
            if (aa == 2) {
                left();
            }
            if (aa == 3) {
                right();
            }
        }

        //算h值
        function calculate_h(state) {
            if (state.length != numbers.length) {
                return 10000;
            }
            let h = 0;
            for (let i = 0; i < numbers.length; i++) {
                if (state[i] != numbers_answer[i]) {
                    h++;
                }

            }
            return h;
        }

        //算部分h值
        function calculate_h_part(state, state_end) {
            if (state.length != state_end.length) {
                return 10000;
            }
            let h = 0;
            for (let i = 0; i < state_end.length; i++) {
                if (state_end[i] == -1) {
                    continue;
                }
                if (state[i] != state_end[i]) {
                    h++;
                }

            }
            return h;
        }

        //檢查state有沒有存在於array裡面
        function state_check(state, state_array) {
            for (let i = 0; i < state_array.length; i++) {
                let aa = 0;
                for (let j = 0; j < state_array[i][1].length; j++) {
                    if (state[j] == state_array[i][1][j]) {
                        aa++;
                    }
                }
                if (aa == state_array[i][1].length) {
                    return true;
                }
            }
            return false;
        }

        //action轉換成文字
        function action_to_text(aa) {
            if (aa == 0) {
                return "up";
            }
            if (aa == 1) {
                return "down";
            }
            if (aa == 2) {
                return "left";
            }
            if (aa == 3) {
                return "right";
            }
            if (aa == 5) {
                return "結束";
            }
        }

        function test() {
            let now = new Date();
            document.getElementById("isCal").innerHTML = String(now.getHours()).padStart(2, '0') + ":" + String(now.getMinutes()).padStart(2, '0') + ":" + String(now.getSeconds()).padStart(2, '0') + " << 如果時間沒在動，就是在計算中...";
        }

        setInterval(draw, 100);
        setInterval(auto_action, 200);
        setInterval(action_array_0, 200);
        setInterval(test, 1000);

    </script>
</body>

</html>